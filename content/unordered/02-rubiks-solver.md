---
title: "rubiks solver in python"
tags: ['cs', 'math', 'project', 'state-space', 'ai', 'python']
---

# building a rubiks solver in python

## rubiks cube representation

in this blog you are going to see both a `cube` object, and the `apply_move, check_solved` functions, 
lets try to implement them.



## the group of rubiks cubes

a group is the ordered pair $(G, \cdot_{G})$, a set $G$ with an action $\cdot_{G} : G \times G \rightarrow G$, that satisfies:
1. associativity: for all $a,b,c\in G$, $(a\cdot_{G} b)\cdot_{G} c = a\cdot_{G}(b\cdot_{G} c)$
2. identity: there exists $e\in G$ such that $\forall a \in G \rightarrow (a \cdot_{G} e) = (e \cdot_{G} a) = a$
3. inverse: $\forall a \in G, \exists a' \in G$ such that $a \cdot_{G} a' = a' \cdot_{G} a = e$ 


a rubiks cube's state is defined by a sequence of moves it takes to achieve it. the cubes $"R"$ and $"U2\space U2 \space R"$ are the same one. we can define multiplication between $2$ rubiks cubes is defined as applying the first's moves and then the second's. For example $"R"\cdot "R2"="R\space \space R2"="R'"$.

the set of all rubik's cube states $G_0$ with the action of multiplication is a group. 
that's because it satisfies all of the group axioms;
1. trivial, because we defined it as a placement in a string
2. $""$, the solved cube is an identity. $"U\space U\space U\space U"$ is also an identity, etc.
3. the inverse for a string $s$ is $s'$, where applying $'$ to a string is inverting the string and applying it element-wise.

lets look at one of the subgroups of $G_0$. <br>
$G_1$ is defined as the subgroup generated by $<U,D,R2,L2,B2,F2>$. it contains all the cubes generated by any combination of these, meaning cubes that can be represented by a string only containing $\{U,D,R2,L2,B2,F2\}$.

notice that the cube $"U'"$ is in $G_1$ because $"U'"="U \space U \space U"$

even though $G_1$ looks complicated it really only represents
all the cube states where the top and bottom faces contain only white or yellow colors.

## a brute-force search

for some context, what we want to develop is an algorithm that comes up with a solution for a given rubiks cube.
a solution is a string $s$ of moves to be applied to the cube such that we get the identity.
meaning that we want an algorithm that takes our messy cube and outputs the inverse, meaning a string $s'$ 
where $s$ is the representing string of our messy cube, which we don't know in advance.

and thats exactly what we want because we know that if we apply the algorithm output to our cube, meaning $s\cdot s'=s\cdot s^{-1}=e$
where $e$ is the solved cube.

the most basic way of finding $s'$ would be to start with out messy cube, and do random moves out of ${U,D,L,R,F,B}$ 
until we arrive at a solved cube, record all the movements we made and give that as the output of our algo.


```python
from rubiks import apply_move, check_solved
from copy import deep_copy
import random

def randomized(cube):
    solution = ""
    while not check_solved(cube):
        random_int = random.randint(0,5) # int between 0 and 5 inclusive.
        for move in {'U', 'D', 'L', 'R', 'F', 'B'}:
            cube = apply_move(cube)
            solution += move

    return solution
```

this implementation has two problems. <br>

1. it rarely finds an optimal solution, lets say the optimal solution is of length $k$,
for `randomized` to output the optimal solution, it would need to guess all the moves correctly.
meaning that it would be correct with probability $\frac{1}{6^k}$, why?
because for each steps there are $6$ possible guesses and each one generates a new branch.
for a "good" random scramble of a cube, the optimal solution is of length $18$ on average.
meaning that this algorithm, assuming that the random distribution is perfectly uniform (which it isn't)
would give an optimal solution with probability $9.846e-15$.

2. it rarely ever stops. there is no flow of current in the search, the algorithm
sees all options as equally good, even those that make it repeat itself or even go back to the beginning.
meaning that the algorithm could theoretically get stuck on an infinite loop, its essentially a random-walk 
over a state space of size of over $43$ quintillion with only $1$ state being a solution.

we are going to solve both these problems, the easiest way to do so is by doing whats called a `breath-first-search`
meaning we will start from our cube and search in all children of depth $1$, depth $2$ and so on for a solution.


```python
from rubiks import apply_move, check_solved
from collections import deque


def bfs(cube):

    q1 = deque([cube])
    q2 = deque()
    depth = 0

    while len(q1)+len(q2) != 0 and depth < 20:
        item = q1.popleft()
    
        for move in {'U', 'D', 'L', 'R', 'F', 'B'}:
            new_cube = apply_move(item, move)
            if new_cube not in q1: 
                q2.append(new_cube)

        if len(q1) == 0:
            q1 = q2
            q2 = deque()
            depth += 1
        
```

we use two deques to not get duplicates and not store all of the previous elements, only the previous ring.


what that guarantees us is two things,

1. an optimal solution, if we haven't found a solution at depth $k-1$ and we went through all smaller depths.
and went through all the states at depth $k-1$, then if we found a solution at depth $k$ that must be an optimal solution.

2. the program will eventually stop, it was proved that every rubiks cube has a solution of length $20$.$^1$
meaning that if we search until a depth of $20$, the program will stop.

thats nice but we still have one lingering problem. which is runtime, 
we based our strategy upon searching until depth $20$, but because there are $6$ possible moves each time, that amounts to $1+6+6^2+6^3+...+6^{20} = \frac{6^{21}-1}{6-1} \approx 6^{20} \approx 3.656e+15$

meaning that even if it took as $1$ millisecond to process a state,
it would still take us approximately $115930$ years to find an optimal solution.

one simple way to reduce the time from $115930$ years to $33.5$ hours would be to instead of doing a depth $20$
search from the messy cube, to do two searches of depth $10$, one from the messy cube and another from the solved cube. it's much better but still non-viable.

we will now switch to heuristics, and precomputed tables.


## the layout of the algorithm


### phase 1 


### phase 2
    heres G1, tables blablabla
    heuristic
    IDA*

## results

---
1. $20$ is called `God's` number