---
title: "intro to cryptography"
tags: ['cs', 'math', 'c', 'linux']
---

[](https://www.2uo.de/myths-about-urandom/#the-csprngs-are-alright)

rdseed

computational-security
information-theoretic security

Shamir's secret sharing 
One time pad

AES, RSA, Diffie-Hellman, Elliptic Curves

## md5
there were some preformance concerns that led replacement of md5 to a linear feedback shift register,
the notion of using md5 as a crpytographic hash wasn't a bad idea but it was broken from the getgo.

## sha1

## smt solver pyz3
breaking linux's lsfr with smt.
lfsr and extension fields and rings

## magma linear algebra tool

## entropy collection
hash functions are good at collecting entropy,


## true randomness or pseudo-random-number-generators?

true randomness can be sqewed and biased.

de-biasing, whitening?

## the notion of security

for cryptography you dont usually want "true randomness"
we cannot guarrantee security against an adversary with infinite compute time, but we can guarrantee security such that it would take all the computers in the world until the heat death of the universe.
unless someone breaks the algorithm itself, using much less computational power.

it doesn't matter if a state-of-the-art hash or algorithm takes in computationally secure random numbers and not information-theoretic secure random numbers, if the hash itself or the encryption algorithm are broken
there is no difference between the two, because the underlying information can be revealed based on the output.
the standard is to use computationally-secure random numbers for your computationally-secure algorithms.
so using `dev/urandom` instead of `dev/random` is good enough.

# dev/urandom, dev/random

how does the linux core calculate `entropy`? it does so by doing a polynomial fit of the arrival times, to the entropy pool. and calculates how "surprising" those arrival times were.
internal hardware restrictions might also influence those arrival times.

has nothing to do with thermodynamics
`man random` is outdated, a myth is that adding entropy is always good no matter the type of entopy, that's not the case, it could bias the RNG. it doesn't affect linux because they thought about user space code trying to do that 

kernel entropy is a myth you don't need to measure it.
 SSL, PGP

# how to randomize 

## how rand() works

rand is a linear congruential generator

a common application would be
```
int main() {
    srand(time(NULL))
    rand()
}
```

rand() % 100
32765

random_shuffle

the implementation in gcc that can be found in link is:

```
int rand() {
  return (((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff);
}
```

### rand() isn't secure

In particular, linear congruential generators (LCGs) suffer from extreme predictability in the lower bits. The k-th bit (starting from k = 0, the lowest bit) has a period of at most 2k + 1 (i.e., how long until the sequence takes to repeat). So the lowest bit has a period of just 2, the second lowest a period of 4, etc. This is why the function above discards the lowest 16 bits, and the resulting output is at most 32767.

time(NULL) is only precise to one second. So if I'm able to guess the second that your program gets run, your program is effectively deterministic.

++
/\ some of [`neal's`](https://codeforces.com/blog/entry/61675) ideas
we should use a much more high-precision clock:
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

Another option is to use the address of a newly allocated heap variable:
mt19937 rng((uint64_t) new char);
++

lets prove that we can break `rand()` lets assume the following code,... blablabla


some months ago my github OTP authenticator wasn't working at all, it didn't guess any verification code correctly, and it was because my computer's time wasn't set up properly, it was off by a minute or so.


there's an intrinsic blablabla
we don't know if its squewed so its not useful by itself
but its very useful to generate 

theres also lava lamp walls, quantum stuff look at alpha phoenix's video on quantum true rng

## how openssl rand() works 
it calls urand in linux

the implementation in openssl that can be found in link is:

```
int rand() {
    return 0
}
```

the entropy generated by the device is greater than the entropy output from it.  This is thee number one criterion for a true hardware number generator. 
differentiating between entropy itself and uniformly distributed random numbers.

## other notable PRNG

linear congruential generator
xorshift
linear-feedback shift register - how to calculate best xor configuration
mersenne twister (mt19937)
dual ec-drgb

how to break SHA-1

## from unifrom to non-uniform sampling

we can use `inverse sampling` or `box-muller` transform to turn our uniform distribution into a non-uniform one
note that non-uniform sampling is not supposed to be used for cryptography

[](https://web.archive.org/web/20230530100652/https://pthree.org/2014/07/21/the-linux-random-number-generator/)
[](https://www.2uo.de/myths-about-urandom/#the-csprngs-are-alright)
[](https://learn.microsoft.com/en-us/shows/goingnative-2013/rand-considered-harmful)
[](https://codeforces.com/blog/entry/61587)
[](https://codeforces.com/blog/entry/61675)
[](https://www.youtube.com/watch?v=Ks1pw1X22y4)