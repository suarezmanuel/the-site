'# building a sudoku solver in python## backtrackinglets look at a sudoku board which i got from [project euler](https://projecteuler.net/problem=96)<div style="text-align: center">    <div class="image-container">        <img src="/files/sudoku.png" alt="sudoku" width="500" height="500">        <label class="image-caption">a common sudoku with zeroes on unfilled cells  - locally sourced   </label>    </div></div>++/\\ notice that sudoku\'s may have multiple correct answers given a specific starting state, the one in the image has only one solutionas you can see sudoku boards have numbers from $[9]$ for filled squares, and $0$ for squares that havent been given a value. $^{1}$ the idea is to fill the zeroes with values from $[9]$, such that;1. in every row there is no duplicate number2. in every column there is no duplicate number3. in every aligned 3x3 box denoted by the bold lines, there is no duplicate number.these are the constraints of the problem.++because there are the same amount of values in a box, row, and column. and there are also no duplicates. you can think of each as a permutation of $[9]$, all the values $[9]$ appear once.im sure there are lot of ways of solving sudoku, but im pretty sure that at the end of the day it boils down to choosing values for the zeroes, and *backtracking* if some constraint was invalidated.<blockquote>from the Oxford dictionary:backtracking - retrace one\'s steps.</blockquote>the simplest way of backtracking is literally as the dictionary says. we look at all the cells that need to be filled, and for each cell try all the values, and if we find some invalidated constraint, we can just `return` meaning we stop exploring the branch. and if there are no `zero` cells, then we return whether its a valid sudoku solution.lets write that,```pythonfrom copy import deepcopysudoku = [[3, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 7, 0, 0, 0], ...]def check_valid(sudoku):    for i in range(9):        values_seen = []        for j in range(9):  # going through each row\'s values            if sudoku[i][j] == 0:                continue  # we don\'t care for 0 values            if sudoku[i][j] in values_seen:                return 0  # dupe found            values_seen.append(sudoku[i][j])    for j in range(9):        values_seen = []        for i in range(9):  # going through each col\'s values            if sudoku[i][j] == 0:                continue  # we don\'t care for 0 values            if sudoku[i][j] in values_seen:                return 0  # dupe found            values_seen.append(sudoku[i][j])    for i in range(3):        for j in range(3):  # going through each block            values_seen = []            for k in range(3):                for l in range(3):                    index_r = 3 * i + k                    index_c = 3 * j + l                    if sudoku[index_r][index_c] == 0:                        continue                    if sudoku[index_r][index_c] in values_seen:                        return 0                    values_seen.append(sudoku[index_r][index_c])    return 1def solve(sudoku):    zero_count = 0    for i in range(9):        for j in range(9):            if sudoku[i][j] == 0:                zero_count += 1                for val in range(9):                    sudoku_copy = deepcopy(sudoku)                    sudoku_copy[i][j] = val                    if solve(sudoku_copy) == 1:  # check if value worked                        return sudoku_copy                    # if it wasnt a valid sudoku try something else.    if zero_count == 0:        return check_valid(sudoku)```in the worst case the runtime is $O(9^{81-k})$ where $k$ is the inital number of filled cells.notice that this code is very inefficient, because we could for each cell only try values that are not duplicates of its `neighbors`,$^{2}$ and save $1$ recursion depth.but why stop there? each time we set a value for a cell we could tell all it\'s `neighbors`to not try that value, and if some cell has $0$ possible values then there is no solution.thats exactly `constriant propagation`.## constraint propagationto start implementing `constraint propagation`, we need to detach from the 2d array of numbers we used and switch to a 2d array of sets. instead of the board holding the current values,it will hold the possible values for each cell. such that if we want to try plotting a value in a cell,we need to remove that value from all its `neighbors` sets.and for each `neighbor` we check after the deletion if its size is zero, and if so there is no solution.lets write that now,++/\\ note that `propagate` now replaces `check_valid`, because the sudoku turns from `valid` to `invalid` iff a value was updated to a "bad one".```pythonfrom copy import deepcopysudoku = [[{1,2,4,5,6,..} {1,2,..}, {1,2,..}, {1,3,4,5,..}, ...], [{1,2,..}, {1,2,..}, {1,2,..}, {2,3,4,5,..}, ...], ...]# returns 0 if the sudoku has no solution, 1 otherwise.def propagate(sudoku, i, j, val):    for k in range(9):  # go through neighbor\'s in row        if i != k and val in sudoku[i][k]:            sudoku[i][k].remove(val)        if len(sudoku[i][k]) == 0:            return 0    for k in range(9):  # go through neighbor\'s in row        if j != k and val in sudoku[k][j]:            sudoku[k][j].remove(val)        if len(sudoku[k][j]) == 0:            return 0    block_i = i // 3    block_j = j // 3    for k in range(3):        for l in range(3):            iter_i = block_i * 3 + k            iter_j = block_j * 3 + l            if (iter_i != i or iter_j != j) and val in sudoku[iter_i][iter_j]:                sudoku[iter_i][iter_j].remove(val)            if len(sudoku[iter_i][iter_j]) == 0:                return 0    return 1  # arrays are passed by reference so no need to `return sudoku`def solve(sudoku):    all_filled = 1    for i in range(9):        for j in range(9):            if len(sudoku[i][j]) > 1:                all_filled = 0                for val in sudoku[i][j]:                    sudoku_copy = deepcopy(sudoku)                    sudoku_copy[i][j] = {val}                    if (                        propagate(sudoku_copy, i, j, val) == 0                    ):  # sudoku_copy is not satisfiable                        continue  # try other values for i,j                    ans, res = solve(sudoku_copy)                    if ans == 1:  # check if value worked                        return ans, res                return 0, sudoku  # no value for i,j gives a solution, so no solution.    if all_filled == 1:        return (            1,            sudoku,        )  # if every dict in `sudoku` is a singleton then its a correct answer.```++the algorithm is based on two facts;1. if the sudoku is completely filled, meaning all dictionaries are singletons. it is a solution for the original sudoku because of the correctness of `propagate`.2. if the sudoku has atleast $1$ cell that has a couple possible values.    a. propagation rules out solutions that are trivially bad.    b. if there is no value for the cell that is part of a solution, then there is no solution.    the algorithm is very simple, in sudoku each cell needs to have a value.so we pick one cell, guess a value for it from the cell\'s dictionary. and make as much work as possible without recursion, which will save us from wasting time on trivially bad sudokus.notice that the algorithm picks its cell by scanning the sudoku `row-major`-wise.that cell could have lots of possible values, and waste time doing heavy recursions on bad values,thus by choosing the cell with least possible values but more than one value, we can cut a lot of runtime.lets write that ```pythondef mrv(sudoku):    min_size = 9  # start with the maximum possible dict size    min_i, min_j = -1, -1    fully_filled = 1    for i in range(9):        for j in range(9):            if min_size > len(sudoku[i][j]) and len(sudoku[i][j]) > 1:                fully_filled = 0                min_size = sudoku[i][j]                min_i = i                min_j = j    if fully_filled == 1:        return -1, -1  # i could just return `min_i, min_j` but we like simplicity    return min_i, min_jdef solve(sudoku):    i, j = mrv(sudoku)    if i == -1 and j == -1:  # (-1,-1) is the return for a fully filled sudoku        return (            1,            sudoku,        )  # if every dict in `sudoku` is a singleton then its a correct answer.    for val in sudoku[i][j]:        sudoku_copy = deepcopy(sudoku)        sudoku_copy[i][j] = {val}        if propagate(sudoku_copy, i, j, val) == 0:  # sudoku_copy is not satisfiable            continue  # try other values for i,j        ans, res = solve(sudoku_copy)        if ans == 1:  # check if value worked            return ans, res    return 0, sudoku  # no value for i,j gives a solution, so no solution.```we managed to write an efficient `CSP` algorithm, now we will make it even faster by switchingto another data structure called the `dancing links` to solve the exact cover problem.## dancing links### what is the exact cover problem?given a collection $S$ of subsets of the set $X$, an exact cover of $X$ by the collection $S$, is a subcollection $S^*$ of $S$ such that every element in $X$ is contained in exactly one subset in $S^*$or in other words, given a collection $S$ of subsets of the set $X$, an exact cover of $X$ by the collection $S$, such that;1. the intersection of any two elements of $S^*$ is empty2. the union of all elements in $S^*$ is equal $X$lets say we have the exact cover problem, meaning we have $S, X$ and want to find $S^*$.<br>we could represent the input as a binary matrix where each column is an element in $X$and every row is an element of $S$ meaning a subset of $X$, where there is a $1$ in a columnif that element in $X$ is present in the subset.for example, for $X=\\{1,2,3\\}, S=\\{\\{1,3\\}, \\{2,3\\}, \\{3\\}\\}$the matrix would be $$\\begin{bmatrix}    1 & 0 & 1 \\\\    0 & 1 & 1 \\\\    0 & 0 & 1 \\\\\\end{bmatrix}$$now, given the matrix we will solve for $S^*$ with the following algortihm## knuth\'s algorithm Xthe algorithm goes as follows, given a matrix $A$1. if the matrix $A$ has no columns, the current partial solution is a valid solution; <br>    terminate successfully2. otherwise, choose a column $c$ deterministically (with mrv for example)3. choose a row $r$ such that $A_{r,c}=1$ nondeterministically4. for each column $j$ such that $A_{r,j}=1$: <br>        a. for each row $i$ such that $A_{i,j}=1$, delete row $i$ from matrix $A$ <br>        b. delete column $j$ from matrix $A$ <br>5. backtrack on step 3 if we haven\'t found a solution++/\\ we need to create new matrices for the backtracking in case we remove a middle row or a middle columnthe idea is that ...because its an exact cover we remove all rows that cover the same elment so we dont cover the same element twice.++thing is that regenerating matrices is very expensive, the overhead from creating matrices would kill the algorithm.thus instead we are going to represent the matrices as `sparse matrices` that will have easy removal of rows, and columns. to do so we are going to use doubly linked lists, to implement `knuth\'s dancing links` data structure.the `dancing links` data structure is made up of 3 main components:1. two headers, a row header and a column header, each a doubly linked list, for easy removal of any given row/column and tracking of current rows/columns2. the doubly linked list the each header has under each item. where each item represents a $1$ on the matrix $A$.heres an image depicting the data structure<div style="text-align: center">    <div class="image-container">        <img src="/files/placeholder.png" alt="sudoku" width="500" height="500">        <label class="image-caption">depiction of the datastructure - locally sourced</label>    </div></div>each node has a `left`, `right`, `up`, `down`.blablablato remove a column, blablato remove a row, blabla```pythondef remove_row ():    return 0 def remove_col ():    return 0 ```to model a sudoku as an `exact cover problem` we need to decide on $S, X$ such that the computed $S^*$ actually means something to us. a solved sudoku is one where all cells satisfy with the constraints. <br>so we can decide on $X=\\{a_{i,j}, b_{i,j}, c_{i,j}, | 0<=i,j<=8, a_{i,j}, b_{i,j}, c_{i,j} \\in {0,1}\\}$ <br>where $a_{i,j}$ is the binary variable that is $1$ if the cell at position $(i,j)$ satisfies rule no $1$, $b_{i,j}, c_{i,j}$ are the same but for rules $2, 3$ respectively. and $S$ being all possible  ## sudoku as a SAT problemwe can model CSP problems using first order logic and use a SAT solver.## other sudoku variantslets say we have another sudoku variant, <div style="text-align: center">    <div class="image-container">        <img src="/files/killer-sudoku.png" alt="sudoku" width="500" height="500">        <label class="image-caption">a more complicated sudoku that uses sums - <a href="https://en.wikipedia.org/wiki/Killer_sudoku">Wikipedia</a></label>    </div></div>this is the killer sudoku variant which is a more strict sudoku, on top of the $3$ normal sudoku rules there is an additional one being that each color must sum to its number.surprisingly, we can make a solver for this variant and for any other variant quite easily, that\'s the magic of CSP.we just gotta represent the new rule as another constraint, let\'s try to represent this CSP as a matrix as we did with the `dancing links`, ---$^{1}: [9]=\\{1,2,3,4,5,6,7,8,9\\}$ <br>$^{2}:$ `neighbors` refers to all the cells it affects (constraint-wise). '